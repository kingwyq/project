#include<bits/stdc++.h>包含了目前c++所包含的所有头文件！！！！
下面一道题：
描述
小Hi有N张纸牌。每张纸牌都有三种属性，每个属性的值可能是0、1、2三种之一。  

现在小Hi想从N张牌中选取3张凑成一套。3张牌可以凑成一套的条件是： 对于每一种属性，这三张牌的值或者两两不同，或者全部相同。  

假设我们用三元组(A, B, C)来表示一张牌，那么(0, 1, 2)(0, 2, 0)(0, 0, 1)可以凑成一套。因为第一种属性都是0；第二种属性分别是1、2、0各不相同；第三种属性分别时2、0、1各不相同。  

小Hi想知道这N张牌一共有多少种凑成一套的选法。

输入
第一行包含一个整数N。  

以下N行每行三个整数A, B, C代表一张牌的三个属性。  

对于30%的数据，1 <= N <= 100  

对于60%的数据，1 <= N <= 1000  

对于100%的数据，1 <= N <= 100000  0 <= A, B, C <= 2

输出
一个整数代表答案

对这个题的分析，因为每张纸牌都可表示为一个三元组，而三元组中每一位只有三种取值，因此，所有的三元组种类共有27种，因此，可以统计每种三元组的个数，对于这个题来说
分两种情况，（1）在一种三元组中选择3个（必定满足条件）（2）选择三个不同种类的三元组，并且满足条件。其他情况都不会满足条件。

辗转相除法求最大公约数gcd(a,b)=gcd(b,a%b),其中gcd表示求最大公约数函数。
唯一分解定理：任意正整数a可以表示为a=p1.^e1*p2.^e2*...*pk.^ek。其中p1,p2,...,pk为素数，且从大到小排列。
因此若a=p1.^e1*p2.^e2*...*pk.^ek;b=p1.^f1*p2.^f2*...*pk.^fk。则a,b的最大公约数为p1.^min(e1,f1)*p2.^min(e2,f2)*...*pk.^min(ek,fk),
最小公倍数可以表示为p1.^max(e1,f1)*p2.^max(e2,f2)*...*pk.^max(ek,fk)，因此,a,b的最大公约数与最小公倍数的乘积=a*b。

一种高效的素数生成方法，构造1-n的素数表，对于小于n的所有数，筛选掉2*p，3*p,...。
int m=sqrt(n+0.5);
for(int i=2;i<=m;i++)
if(!vis[i])
for(int j=i*i;j<=n;j+=i)
vis[j]=1;

关于求逆元：
在有些题目中需要对某个很大的数（一般可以表示成连乘的形式）取模，而且模除的那个数一般都是质数。例如对C（n,k）取模，C（n,k）可以分为分子部分和分母部分
分子，分母各自表示为连乘的形式，但是最终可能是一个结果很大的数，long long类型都可能存不下，因此，需要对其取模，只能每步都取模，但是，这里涉及到除法
。一种解决方式就是应用逆元，由费马小定理可知a.^(p-1) mod p =1,因此如果分母是a的话，而结果是对p取余，并且p必须为质数，此时，给分子乘以a.^(p-1)结果
不会改变，此时，除以a就可以变为乘以a.^(p-2)（被分母约去一个a），通过这样转化，就可以解决含除法求余的问题。

唯一分解式的应用：
例如求C（p，q）/C（r，s）当p,q,r,s比较大的时候，此时，直接计算是不可能的，由于C(m,n)=m!/(n!(m-n)!),首先可以根据数据规模确定素数集的大小，将素数集
首先保存下来，然后，无论是m!,n!还是其他都可以表示成素数的k次幂相乘的形式，可以将幂次单独保存起来，分子上的幂次为正，分母上的为负，最终抵消完之后，用
所有素数，以及其对应的幂，连乘即是最后结果。具体参考（算法竞赛书p316）
