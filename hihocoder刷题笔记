#include<bits/stdc++.h>包含了目前c++所包含的所有头文件！！！！
下面一道题：
描述
小Hi有N张纸牌。每张纸牌都有三种属性，每个属性的值可能是0、1、2三种之一。  

现在小Hi想从N张牌中选取3张凑成一套。3张牌可以凑成一套的条件是： 对于每一种属性，这三张牌的值或者两两不同，或者全部相同。  

假设我们用三元组(A, B, C)来表示一张牌，那么(0, 1, 2)(0, 2, 0)(0, 0, 1)可以凑成一套。因为第一种属性都是0；第二种属性分别是1、2、0各不相同；第三种属性分别时2、0、1各不相同。  

小Hi想知道这N张牌一共有多少种凑成一套的选法。

输入
第一行包含一个整数N。  

以下N行每行三个整数A, B, C代表一张牌的三个属性。  

对于30%的数据，1 <= N <= 100  

对于60%的数据，1 <= N <= 1000  

对于100%的数据，1 <= N <= 100000  0 <= A, B, C <= 2

输出
一个整数代表答案

对这个题的分析，因为每张纸牌都可表示为一个三元组，而三元组中每一位只有三种取值，因此，所有的三元组种类共有27种，因此，可以统计每种三元组的个数，对于这个题来说
分两种情况，（1）在一种三元组中选择3个（必定满足条件）（2）选择三个不同种类的三元组，并且满足条件。其他情况都不会满足条件。

辗转相除法求最大公约数gcd(a,b)=gcd(b,a%b),其中gcd表示求最大公约数函数。
唯一分解定理：任意正整数a可以表示为a=p1.^e1*p2.^e2*...*pk.^ek。其中p1,p2,...,pk为素数，且从大到小排列。
因此若a=p1.^e1*p2.^e2*...*pk.^ek;b=p1.^f1*p2.^f2*...*pk.^fk。则a,b的最大公约数为p1.^min(e1,f1)*p2.^min(e2,f2)*...*pk.^min(ek,fk),
最小公倍数可以表示为p1.^max(e1,f1)*p2.^max(e2,f2)*...*pk.^max(ek,fk)，因此,a,b的最大公约数与最小公倍数的乘积=a*b。

一种高效的素数生成方法，构造1-n的素数表，对于小于n的所有数，筛选掉2*p，3*p,...。
int m=sqrt(n+0.5);
for(int i=2;i<=m;i++)
if(!vis[i])
for(int j=i*i;j<=n;j+=i)
vis[j]=1;

关于求逆元：
在有些题目中需要对某个很大的数（一般可以表示成连乘的形式）取模，而且模除的那个数一般都是质数。例如对C（n,k）取模，C（n,k）可以分为分子部分和分母部分
分子，分母各自表示为连乘的形式，但是最终可能是一个结果很大的数，long long类型都可能存不下，因此，需要对其取模，只能每步都取模，但是，这里涉及到除法
。一种解决方式就是应用逆元，由费马小定理可知a.^(p-1) mod p =1,因此如果分母是a的话，而结果是对p取余，并且p必须为质数，此时，给分子乘以a.^(p-1)结果
不会改变，此时，除以a就可以变为乘以a.^(p-2)（被分母约去一个a），通过这样转化，就可以解决含除法求余的问题。

唯一分解式的应用：
例如求C（p，q）/C（r，s）当p,q,r,s比较大的时候，此时，直接计算是不可能的，由于C(m,n)=m!/(n!(m-n)!),首先可以根据数据规模确定素数集的大小，将素数集
首先保存下来，然后，无论是m!,n!还是其他都可以表示成素数的k次幂相乘的形式，可以将幂次单独保存起来，分子上的幂次为正，分母上的为负，最终抵消完之后，用
所有素数，以及其对应的幂，连乘即是最后结果。具体参考（算法竞赛书p316）

**priority_queue学习
模板申明带3个参数：priority_queue<Type, Container, Functional>，其中Type 为数据类型，Container为保存数据的容器，Functional 为元素比较方式。
Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector。
 比较方式默认用operator<，所以如果把后面2个参数缺省的话，优先队列就是大顶堆（降序），队头元素最大。
 以下代码实现重载大于号操作，实现了小顶堆。
 #include<bits/stdc++.h>
using namespace std;
struct Node{
	int x,y;
	Node(int a,int b):x(a),y(b){};
};
bool operator >(Node a,Node b)//重载大于号是小顶堆，最大的元素在最后 
{
	if(a.x==b.x) return a.y>b.y;
	return a.x>b.x;
}
int main(void)
{
	priority_queue< Node,vector<Node>,greater<Node> > que;
	Node n1(3,1);
	Node n2(4,2);
	Node n3(3,2);
	que.push(n1);
	que.push(n2);
	que.push(n3);
	while(!que.empty())
	{
		cout<<que.top().x<<","<<que.top().y<<endl;
		que.pop();
	}
	return 0;
}
自定义类型重载operator<后，声明对象时就可以只带一个模板参数。
小的会放在后面，自定义类型需要重载<号，用来比较自定义的元素大小，两个元素通过比较，哪个小哪个放后面，队头是最大的元素。
下面这段程序，自定义类型中有两个成员，这里的大小界定逻辑是若x不相同则认为x小的更小，若x相同则认为y小的更小。
#include<bits/stdc++.h>
using namespace std;
struct Node{
	int x,y;
	Node(int a,int b):x(a),y(b){};
};
bool operator <(Node a,Node b)
{
	if(a.x==b.x) return a.y<b.y;
	return a.x<b.x;
}
int main(void)
{
	priority_queue< Node > que;
	Node n1(3,1);
	Node n2(4,2);
	Node n3(3,2);
	que.push(n1);
	que.push(n2);
	que.push(n3);
	while(!que.empty())
	{
		cout<<que.top().x<<","<<que.top().y<<endl;
		que.pop();
	}
	return 0;
}
如果将上面程序中的操作符重载函数改变为下面的程序：
bool operator <(Node a,Node b)
{
	if(a.x==b.x) return a.y>b.y;
	return a.x>b.x;
}
只是上面微小改变，就可实现将上面的大顶堆改为小顶堆。
