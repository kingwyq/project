传统的io一次只能处理一个客户端的连接请求(在单线程的情况下)，如果要能够同时处理多个客户端的请求，需要为每个与服务器建立连接的客户端分配一个线程，在线程中
处理服务器与客户端的交互任务，而主线程只负责接收客户端的连接请求，并分配相应线程。该方式的缺点是需要为每个连接开启一个独立的线程，在连接数量庞大的情况下
非常消耗资源。
nio(new io)该io是非阻塞的(nio在单线程的情况下能够及时与请求客户端建立连接，不会因为在循环处理与其他客户端的交互而无法及时响应客户端连接)，一个线程可以为
多个用户服务，在nio中每个连接就是一个通道，每个通道在selector中注册，//并且设置通道对应的事件响应，主线程中通过轮询的方式检测是否有准备就绪的通道(连接)
可以处理，通过返回的迭代器对象可以拿到每个可以处理的连接，然后对其进行处理。

在 NIO 中，抛弃了传统的 I/O 流，而是引入了 Channel 和 Buffer 的概念。在 NIO 中，只能从 Channel 中读取数据到 Buffer 中或将数据从 Buffer 中写入到 
Channel。

阻塞与非阻塞的理解
这里说的阻塞和非阻塞其实是指的socket或channel读取数据的方法是否阻塞。socket的读取方法是阻塞的，而channel的read方法是非阻塞的。(个人理解，socket的read
之所以会阻塞是因为虽然服务器与客户端之间建立连接，但是却不一定会传输数据，而当不传输数据时服务器端会因接收不到数据而阻塞，直到有数据才会继续执行，但是对nio中
的channel而言，如果准备就绪的事件不被触发，那么该channel就不会被处理，能够被处理的channel一定是已经接收到客户端数据的，这样在拿到channel后就可以直接处理
，此时就不会阻塞)。

netty是一个nio框架，boss负责监听端口，workers负责读写，当boss获取到一个channel后会从一个workers中选取一个worker并将channel绑定到它的selector上。当
worker接收到事件的时候，它会在自己的selector上选取就绪channel进行相应读写操作。
